# 2.2. 直方图 Histograms

在学习直方图之前，我们需要先了解几个概念

## 画布的概念 Canvas

画布有很多的类供你个性化你的图标，比如调整坐标轴的形式、范围、标题名称、轴名称等等：

<details>

<summary>Canvas类的成员函数</summary>

```c
root [0] TCanvas *c1 = new TCanvas("c1","c1",600,600)
(TCanvas *) 0x14d73e360
root [1] c1->
AbsCoordinates
AbsPixeltoX
AbsPixeltoXY
AbsPixeltoY
AbstractMethod
AddExec
AppendPad
AreAllSignalsBlocked
AreSignalsBlocked
AutoExec
BlockAllSignals
BlockSignals
Browse
BuildLegend
ChangedBy
CheckedHash
Class
ClassName
Class_Name
Class_Version
Clear
ClearPadSave
Cleared
Clip
ClipPolygon
ClippingCode
Clone
Close
CloseToolTip
Closed
CollectClassSignalLists
Compare
Connect
Connected
Constructor
Copy
CopyPixmap
CopyPixmaps
CreateToolTip
DeclFileLine
DeclFileName
Delete
DeleteCanvasPainter
DeleteExec
DeleteToolTip
Destroyed
Destructor
Dictionary
Disconnect
DisconnectWidget
Disconnected
DistancetoLine
DistancetoPrimitive
Divide
DivideSquare
Draw
DrawClass
DrawClassObject
DrawClone
DrawClonePad
DrawCollideGrid
DrawColorTable
DrawCrosshair
DrawFrame
Dump
EditorBar
EmbedInto
Emit
EnterLeave
Error
EventPave
Execute
ExecuteEvent
ExecuteEventAxis
Fatal
FeedbackMode
FindObject
Flush
ForceUpdate
GetAbsHNDC
GetAbsWNDC
GetAbsXlowNDC
GetAbsYlowNDC
GetAfile
GetAspectRatio
GetAstat
GetAutoExec
GetBBox
GetBBoxCenter
GetBorderMode
GetBorderSize
GetBottomMargin
GetCanvas
GetCanvasID
GetCanvasImp
GetCanvasPainter
GetCanvasPar
GetClickSelected
GetClickSelectedPad
GetContextMenu
GetCrosshair
GetDISPLAY
GetDoubleBuffer
GetDrawOption
GetDtorOnly
GetEvent
GetEventX
GetEventY
GetFillColor
GetFillStyle
GetFrame
GetFrameBorderMode
GetFrameBorderSize
GetFrameFillColor
GetFrameFillStyle
GetFrameLineColor
GetFrameLineStyle
GetFrameLineWidth
GetGLDevice
GetGridx
GetGridy
GetHNDC
GetHighLightColor
GetIconName
GetLeftMargin
GetLineColor
GetLineStyle
GetLineWidth
GetListOfClassSignals
GetListOfConnections
GetListOfExecs
GetListOfPrimitives
GetListOfSignals
GetLogx
GetLogy
GetLogz
GetMaxPickDistance
GetMother
GetName
GetNumber
GetObjectInfo
GetObjectStat
GetOption
GetPad
GetPadPaint
GetPadPar
GetPadPointer
GetPadSave
GetPainter
GetPhi
GetPixmapID
GetPrimitive
GetRange
GetRangeAxis
GetRightMargin
GetSelected
GetSelectedOpt
GetSelectedPad
GetSelectedX
GetSelectedY
GetShowEditor
GetShowEventStatus
GetShowToolBar
GetShowToolTips
GetTheta
GetTickx
GetTicky
GetTitle
GetTopMargin
GetUniqueID
GetUxmax
GetUxmin
GetUymax
GetUymin
GetView
GetView3D
GetViewer3D
GetVirtCanvas
GetWNDC
GetWh
GetWindowHeight
GetWindowTopX
GetWindowTopY
GetWindowWidth
GetWw
GetX1
GetX2
GetXfile
GetXlowNDC
GetXsizeReal
GetXsizeUser
GetXstat
GetY1
GetY2
GetYfile
GetYlowNDC
GetYsizeReal
GetYsizeUser
GetYstat
HandleInput
HandleTimer
HasConnection
HasCrosshair
HasFixedAspectRatio
HasInconsistentHash
HasMenuBar
HasViewer3D
Hash
HighLight
HighPriority
HighlightConnect
Highlighted
Iconify
ImplFileLine
ImplFileName
IncrementPaletteColor
Info
InheritsFrom
Inspect
InvertBit
IsA
IsBatch
IsBeingResized
IsDestructed
IsDrawn
IsEditable
IsEqual
IsFolder
IsGrayscale
IsModified
IsOnHeap
IsRetained
IsSortable
IsTransparent
IsVertical
IsWeb
IsZombie
LowPriority
MakeDefCanvas
MayNotUse
Message
Modified
Modify
MoveOpaque
NextPaletteColor
Notify
NumberOfConnections
NumberOfSignals
Obsolete
OpaqueMoving
OpaqueResizing
Pad
PadInHighlightMode
PadInSelectionMode
PadtoX
PadtoY
Paint
PaintBorderPS
PaintBox
PaintFillArea
PaintFillAreaHatches
PaintFillAreaNDC
PaintHatches
PaintLine
PaintLine3D
PaintLineNDC
PaintModified
PaintPadFrame
PaintPolyLine
PaintPolyLine3D
PaintPolyLineNDC
PaintPolyMarker
PaintText
PaintTextNDC
Pick
Picked
PixeltoX
PixeltoXY
PixeltoY
PlaceBox
Pop
PopTopLevelSelectable
Print
ProcessedEvent
PushSelectableObject
PushTopLevelSelectable
RaiseWindow
Range
RangeAxis
RangeAxisChanged
RangeChanged
Read
RecordLatex
RecordPave
RecursiveRemove
RedrawAxis
ReleaseViewer3D
ResetAttFill
ResetAttLine
ResetAttPad
ResetBit
ResetDrawn
ResetToolTip
ResetView3D
Resize
ResizeOpaque
ResizePad
Resized
SaveAs
SaveFillAttributes
SaveLineAttributes
SavePrimitive
SaveSource
Selected
SetAfile
SetAstat
SetAttFillPS
SetAttLinePS
SetAttMarkerPS
SetAttTextPS
SetBBoxCenter
SetBBoxCenterX
SetBBoxCenterY
SetBBoxX1
SetBBoxX2
SetBBoxY1
SetBBoxY2
SetBatch
SetBit
SetBorderMode
SetBorderSize
SetBottomMargin
SetCanvas
SetCanvasImp
SetCanvasSize
SetClickSelected
SetClickSelectedPad
SetCopyGLDevice
SetCrosshair
SetCursor
SetDoubleBuffer
SetDrawOption
SetDtorOnly
SetEditable
SetFillAttributes
SetFillColor
SetFillColorAlpha
SetFillStyle
SetFixedAspectRatio
SetFolder
SetFrameBorderMode
SetFrameBorderSize
SetFrameFillColor
SetFrameFillStyle
SetFrameLineColor
SetFrameLineStyle
SetFrameLineWidth
SetGLDevice
SetGrayscale
SetGrid
SetGridx
SetGridy
SetHighLightColor
SetLeftMargin
SetLineAttributes
SetLineColor
SetLineColorAlpha
SetLineStyle
SetLineWidth
SetLogx
SetLogy
SetLogz
SetMargin
SetMaxPickDistance
SetName
SetNumber
SetObjectStat
SetPad
SetPadSave
SetPhi
SetRealAspectRatio
SetRetained
SetRightMargin
SetSelected
SetSelectedPad
SetSupportGL
SetTheta
SetTicks
SetTickx
SetTicky
SetTitle
SetToolTipText
SetTopMargin
SetUniqueID
SetVertical
SetView
SetViewer3D
SetWindowPosition
SetWindowSize
SetXfile
SetXstat
SetYfile
SetYstat
Show
ShowGuidelines
ShowMembers
Size
StartEditing
Streamer
StreamerNVirtual
SupportAlpha
SysError
TAttBBox2D
TAttFill
TAttLine
TAttPad
TCanvas
TObject
TPad
TQObject
TVirtualPad
TestBit
TestBits
ToggleAutoExec
ToggleEditor
ToggleEventStatus
ToggleToolBar
ToggleToolTips
UnZoomed
Update
UseCurrentStyle
UseGL
UtoAbsPixel
UtoPixel
VtoAbsPixel
VtoPixel
WaitPrimitive
Warning
Write
XYtoAbsPixel
XYtoPixel
XtoAbsPixel
XtoPad
XtoPixel
YtoAbsPixel
YtoPad
YtoPixel
cd
kAutoExec
kBitMask
kCanDelete
kCannotMove
kCannotPick
kClearAfterCR
kClipFrame
kFraming
kHasUUID
kHori
kInconsistent
kInvalidObject
kIsGrayscale
kIsOnHeap
kIsReferenced
kMenuBar
kMoveOpaque
kMustCleanup
kNoContextMenu
kNotDeleted
kObjInCanvas
kOverwrite
kPrintingPS
kResizeOpaque
kShowEditor
kShowEventStatus
kShowToolBar
kShowToolTips
kSingleKey
kWriteDelete
kZombie
ls
operator delete
operator delete[]
operator new
operator new[]
operator=
x3d
```

</details>



## 箱的概念 bin

在前一个例子中，你会看到`TH1I("h1", "h1 title",100,0.0,4.0)`中的参数，如`"h1"`表示将图片存为文件时，默认文件名为`h1`，`"h1 title"`指该histogram的标题为`h1 title`，`100,0.0,4.0`分别表示分bin数量`(nbins)`和轴范围`(xlow,xup)`，即将`0.0-4.0`的范围上分`100`个`bin`

那么什么是bin？<mark style="color:green;">bin的原意是垃圾箱或小箱子</mark>，在histogram中，我们将存放数据的bar，称为一个bin，bin的宽度取决于分bin数量及坐标轴的形式，如`SetLogx`：对x轴取对数坐标的形式，bin的大小随log变化，如果要求bin宽不随`logx`变化，可以参考[这里](https://www.bilibili.com/read/cv6640287/)

当不指定bin及坐标轴范围时（参数位置需要空出），ROOT会自动帮你匹配，<mark style="color:red;">自动的通常很丑</mark>

```cpp
   TH1* h1 = new TH1I("h1", "h1 title", , , );   // 一维整型直方图
```

<mark style="color:red;">同样，我们也可以精细控制分bin，此时请注意，数组的大小应为</mark><mark style="color:red;">`nbins+1`</mark><mark style="color:red;">，因为它包含下范围和上范围的轴值</mark> <mark style="color:red;"></mark>_<mark style="color:red;">**E.g.**</mark>_

```cpp
   double binEdges[] = { 0.0, 0.2, 0.5, 1., 2., 4. };
   TH1* h1 = new TH1D("h1", "h1 title", 6, binEdges );
   TH2* h2 = new TH2D("h2", "h2 title", 6, binEdges , 30, -1.5, 3.5);
```

<mark style="color:green;">**在命令行模式下，我们也可以通过下面的命令来完成简单的分bin：**</mark>

`root [0] TTree->Draw("TBranch>>(nbin,xlim,xup)")`

<mark style="color:green;">**(二维图使用>>(xbin,xmin,xmax,ybin,ymin,ymax)命令)**</mark>



## 1D Histogram

Histogram是一种对数据分布情况的图形表示方式，适合用来表现数量上的差异。

一维histogram的标准形式是（参数可以省略）：

```cpp
TH1 *h1 = new TH1I("h1", "h1 title; x title; unit title", bins, x min, x max)
```

从C++11开始新建一个对象可以用auto，其类型可自动匹配：

```c
auto *h1 = new TH1F;
```

<mark style="color:red;">**建立histogram之后，必须向其中填充数据：**</mark>

```c
h1->Fill(x);         // 填入一个值x
h1->Fill(x, w);      // 以权重为w填入一个值x
```

### 随机数填充

通常用于产生一个随机样本

<details>

<summary>E.g. 填充和绘制Gaus <strong>histogram</strong></summary>

<pre class="language-c"><code class="lang-c"><strong>#include &#x3C;fstream>  // file stream
</strong>
void ana(){
    TH1F *h1 = new TH1F("h1","Histogram Gaus",1000,-5,8);
    // Type Histogram 1D Float(example:TH1D = Type Histogram 1D Double)
    float data = 0.0;

    ifstream read; // input file stream
    read.open("data.txt");

    while(read.is_open()){
        read >> data;
        h1->Fill(data);
        if(read.eof()) break;   // .eof() = end of file()
    }
    h1->Draw();
}
</code></pre>

</details>

<figure><img src="../.gitbook/assets/unnamed.svg" alt=""><figcaption></figcaption></figure>

### 坐标点填充

histogram也可以仅依靠坐标来绘制 _**E.g.**_

<details>

<summary>E.g. 不同实验对GRB221009A的不同能量的光变曲线的测量结果</summary>

```c
#include <iostream>
#include <fstream>
#include <vector>
#include <TCanvas.h>
#include <TH1F.h>

void plot() {
	
	TCanvas *canvas = new TCanvas("canvas", "Histogram", 800, 800);
	canvas->Divide(1,4,0);
	
	TH1F *h1 = new TH1F("h1", "", 120, 0, 1200);
	std::ifstream file1("lightCurve221009AHxmt.txt");
	double x1, y1;
	while (file1 >> x1 >> y1) {h1->Fill(x1, y1);}
	h1->SetTitle(";;Rate [counts/bin]");
	h1->GetYaxis()->SetTitleSize(0.06);h1->GetYaxis()->CenterTitle();

	TH1F *h2 = new TH1F("h2","",120,0,1200);
	std::ifstream file2("lightCurve221009AFermi.txt");
	double x2, y2;
	while (file2 >> x2 >> y2) {h2->Fill(x2, y2);}
	h2->SetTitle(";;Rate [counts/bin]");
	h2->GetYaxis()->SetTitleSize(0.06);h2->GetYaxis()->CenterTitle();

	TH1F *h3 = new TH1F("h3","",120,0,1200);
	std::ifstream file3("lightCurve221009ALhaaso.txt");
	double x3, y3;
	while (file3 >> x3 >> y3) {h3->Fill(x3, y3);}
	h3->SetTitle(";;Rate [counts/bin]");
	h3->GetYaxis()->SetTitleSize(0.06);h3->GetYaxis()->CenterTitle();

    TH1F *h4 = new TH1F("h4","",120,0,1200);
    std::ifstream file4("lightCurve221009AHadar.txt");
    double x4, y4;
    while (file4 >> x4 >> y4) {h4->Fill(x4, y4*2);}
	h4->SetTitle(";T-T_0 [s];Rate [counts/bin]");
	h4->GetYaxis()->SetTitleSize(0.06);h4->GetYaxis()->CenterTitle();
	h4->GetXaxis()->SetTitleSize(0.06);h4->GetXaxis()->CenterTitle();

    canvas->cd(1);
	gStyle->SetOptStat(0);
	h1->SetFillColor(kYellow-6);
	h1->Draw("HIST");
	TLegend *l1 = new TLegend(0.6,0.6,0.893,0.89,"HXMT HE/Csl");
	l1->AddEntry(h1,"0.6-3MeV");
    l1->SetBorderSize(0);l1->Draw();

    canvas->cd(2);
	gStyle->SetOptStat(0);
    h2->SetFillColor(kGreen-6);
    h2->Draw("HIST");
    TLegend *l2 = new TLegend(0.6,0.6,0.893,0.89,"Fermi LAT");
    l2->AddEntry(h2,"0.1-500GeV");
    l2->SetBorderSize(0);l2->Draw();
    
    canvas->cd(3);
	gStyle->SetOptStat(0);
    h3->SetFillColor(kBlue-6);
    h3->Draw("HIST");
    TLegend *l3 = new TLegend(0.6,0.6,0.893,0.89,"LHAASO WCDA");
    l3->AddEntry(h3,"0.2-7TeV");
    l3->SetBorderSize(0);l3->Draw();
    
    canvas->cd(4);
	gStyle->SetOptStat(0);
    h4->SetFillColor(kMagenta-6);
    h4->Draw("HIST");
    TLegend *l4 = new TLegend(0.6,0.6,0.893,0.89,"HADAR");
    l4->AddEntry(h4,"0.01-10TeV");
    l4->SetBorderSize(0);l4->Draw();
    
	//canvas->Update();
}

```

</details>

<details>

<summary>E.g. 带拟合的坐标点填充</summary>

```c
#include <iostream>
#include <fstream>
#include <vector>
#include <TCanvas.h>
#include <TH1F.h>
#include <TF1.h>

void plot() {
	gStyle->SetOptStat(0);
	gStyle->SetOptFit(1);
	TCanvas *canvas = new TCanvas("canvas", "Histogram", 800, 800);
	
	TH1F *h1 = new TH1F();
	h1->SetBins(50000,0,50000);
	std::ifstream file1("CH1.csv");
	double x1, y1;
	TTree* t = new TTree();
	int x;
	double y;
	t->ReadFile("CH1.txt","x/I:y/D");
	t->SetBranchAddress("x",&x);
	t->SetBranchAddress("y",&y);
	for (int i=0; i<t->GetEntries();i++)	{
		t->GetEntry(i);
		cout << x << " " << y << endl;
		h1->SetBinContent(x,y);
	}
	
	h1->SetTitle("T;time [ps];counts");
	h1->GetYaxis()->SetTitleSize(0.06);
	h1->GetYaxis()->CenterTitle();
	double max;
	int maxbin;
	TF1* func = new TF1();
	double mean,sigma;
	maxbin = h1->GetMaximumBin();
	max = h1->GetBinCenter(maxbin);
	h1->Fit("gaus","","",max-100,max+100);
	func = h1->GetFunction("gaus");
	mean  = func->GetParameter(1);
	sigma  = func->GetParameter(2);
	h1->Fit("gaus","","",mean-1.2*sigma,mean+1.2*sigma);
	func = h1->GetFunction("gaus");
	mean  = func->GetParameter(1);
	sigma  = func->GetParameter(2);
	h1->Fit("gaus","","",mean-1.2*sigma,mean+1.2*sigma);
	func = h1->GetFunction("gaus");
	mean  = func->GetParameter(1);
	sigma  = func->GetParameter(2);
	h1->Fit("gaus","","",mean-1.2*sigma,mean+1.2*sigma);
	func = h1->GetFunction("gaus");
	func = h1->GetFunction("gaus");
	mean  = func->GetParameter(1);
	sigma  = func->GetParameter(2);
	h1->Fit("gaus","","",mean-1.*sigma,mean+1.*sigma);

	canvas->cd(1);
	gStyle->SetOptStat();
	//h1->SetFillColor(kYellow-6);
//	h1->Draw("hist f1");
//	f1->Draw("same");
	h1->GetXaxis()->SetRangeUser(39000,40500);
	canvas->SaveAs("h1.root");
    
	//canvas->Update();
}

```

</details>

### 查看、获取和更改bin中的内容

`GetBinEntries(i)`，用于获取TProfile对象中第i个bin的数据点数量；

`GetBinContent(i)`，用于获取TProfile对象中第i个bin的内容，即该bin中的数据值；

带有误差条的写入bin&#x20;

```c
histo->SetBinContent(i+1, data[i]); histo->SetBinError(i+1, TMath::Sqrt(data[i])), bin从1开始
```

`GetBinError(i)`，用于获取TProfile对象中第i个bin的（上）误差；

`GetBinErrorLow(i)`，用于获取TProfile对象中第i个bin的下误差；

`GetXaxis()->GetBinCenter(i)`，获取TProfile对象中X轴上第i个bin的中心值；

`GetBinWidth(i)`，用于获取直方图中第i个bin的宽度；

`GetBinXYZ(i, j, k)`，这个函数用于获取多维直方图中（例如TH3）的第(i, j, k)个bin的内容。

`gPad->GetUymax()`, 获取坐标轴的最大值，在此之前需要运行`c1->Update()`

`GetQuantiles(nq, yq, xq)`，分为函数，假设我们有一个包含1000个随机数的直方图，我们希望计算出它的四分位数（即分位数数量为4）。以下是一个示例代码：

```c
#include <TH1F.h>
#include <TMath.h>
#include <TRandom3.h>

void calculateQuantiles() {
    // 创建一个一维直方图
    TH1F *histogram = new TH1F("histogram", "Random Numbers", 100, 0, 100);

    // 生成一些随机数并填充到直方图中
    TRandom3 random;
    for (int i = 0; i < 1000; ++i) {
        histogram->Fill(random.Uniform(0, 100));
    }

    // 计算四分位数
    int nq = 4;
    double xq[nq];
    double yq[nq];
    for (int i = 0; i < nq; ++i) {
        xq[i] = double(i + 1) / nq;
    }
    histogram->GetQuantiles(nq, yq, xq);

    // 打印输出计算得到的四分位数
    for (int i = 0; i < nq; ++i) {
        std::cout << "Quantile " << i+1 << " at position " << xq[i] << " is " << yq[i] << std::endl;
    }
}
```

在这个例子中，我们首先创建了一个包含100个bin的一维直方图，然后生成了1000个0到100之间的随机数，并将它们填充到直方图中。接着，我们计算了四分位数，并将结果存储在数组 `yq` 中。最后，我们打印输出了计算得到的四分位数值。

通过这个例子，我们可以更好地理解`GetQuantiles`函数的作用，以及如何使用它来计算直方图中指定分位数位置的数值。



## 2D Histogram

二维histogram的标准形式是（参数可以省略）：

```c
TH2* h2 = new TH2F("h2", "h2 title; x title; y title", x bins, x min, x max, y bins, y min, y max);
```

#### 将2维Histogram的X轴投影赋值给Hist1

```
Hist1 = Hist2->ProjectionX();
```

#### 一次新建多个Hist对象并设置名称

```
TH1F *h[n];
```

#### histogram和histogram之间也可以完成简单的运算

```
TH3* h3 = new TH3D("h3", "h3 title; x title; y title; z title");
TH1F h3 = h1*h2;
TH1F h3 = 8*h1;
```

现在我们可以用上面的例子生成一幅二维直方图

<details>

<summary>E.g. XY双高斯2维histogram</summary>

```c
{
   TH2D h2("h2","Histogram filled with random numbers",40,-4,4,40,-20,20);
   float px, py;
   for (int i = 0; i < 25000; i++) {
      gRandom->Rannor(px,py);
      h2.Fill(px,5*py);
   }
   h2.DrawCopy("LEGO1");
}
```

</details>

<figure><img src="../.gitbook/assets/histogram2dgaus.svg" alt=""><figcaption></figcaption></figure>

<details>

<summary>E.g. 1维高斯和2维高斯投影，及多种2维展示风格</summary>

```c
void histogram2D(){
    TCanvas *c = new TCanvas("c","c",800,1200);
    c->Divide(2,3); 
    //新建画布800*1200，布局为2*3，横*高，主函数名需与文件名一致，即该文件名为"histogram3D.c"
    float x,y;
    TH1F *h1 = new TH1F("h1","1D histogram",50,-10,10);
    TH2F *h2 = new TH2F("h2","2D histogram",50,-10,10,50,-10,10);
    TH2F *h3 = new TH2F("h3","2D histogram",50,-10,10,50,-10,10);
    TH1D *ph;   //一维投影
 
    for (int i=0;i<30000;i++){
        x=gRandom->Gaus(0,0.5);
        y=gRandom->Gaus(0,1);
        h1->Fill(3*x);
        h2->Fill(x,y);
        h3->Fill(x,y);
    }

    c->cd(1);
    h1->Draw();

    c->cd(2);
    h2->Draw("lego");

    c->cd(3);
    h3->Draw("lego2");

    c->cd(4);
    ph = h2->ProjectionX();
    ph->SetTitle("The projection of n2 on X");
    ph->Draw();
}
```

</details>

<figure><img src="../.gitbook/assets/histogram3d.svg" alt=""><figcaption></figcaption></figure>

#### 同样可以在命令行中，为现有画布新建图像

```shell
root [1] c->cd(5)
(TVirtualPad *) 0x376dbd0
root [2] TF1 *f1 = new TF1("f1","sin(x)/x",-10,10)
(TF1 *) 0x3b2d290
root [3] f1->Draw()
root [4] 
```

<figure><img src="../.gitbook/assets/histogram3d2 (1).svg" alt=""><figcaption></figcaption></figure>

### 蜂巢图



### 乐高图



### box图

















## TProfile

TProfile可以看作是THistogram的一种特殊情况，用于处理两个变量之间的关系。在实际使用中，THistogram通常用于表示数据的分布情况，而TProfile用于表示两个变量之间的关系。



## 随机函数 gRandom

```c
// 常用的内置随机函数
gRandom->Binomial(ntot,p)    // 二项分布
gRandom->Exp(tau)            // 指数分布
gRandom->Gaus(mean,sigma)    // 高斯分布
gRandom->Rndm()              // (0,1]均匀分布
gRandom->Poisson(mean)       // 泊松分布
gRandom->Landau(mean,sigma)  // 朗道分布
gRandom->Uniform(x1,x2)      // (x1,x2]均匀分布
```

<details>

<summary><strong>E.g. 创建Gaus数据</strong> </summary>

```cpp
#include <fstream>  // 当用到文件输入输出流时需要添加该头文件

void create_data(){    // 在ROOT中，文件名与主函数名 
    float data=0.0;
    ofstream write; // out of file stream;stream name
    write.open("data.txt"); 

    for (int i=0; i<30000;i++){
        data = gRandom -> Gaus (2,0.3);    // gaus分布的均值和宽度
        write << data <<"\n";   // data write in stream
    }
    for (int k=0;k<30000;k++){
        data = gRandom -> Gaus (-2,0.5);
        write << data <<"\n";
    }
    write.close();
    cout << "completed!"<<endl;
}
```

</details>



## 绘图选项

**Options supported for 1D and 2D histograms**

<table><thead><tr><th width="125.5">Option </th><th>Description </th></tr></thead><tbody><tr><td>"E" </td><td>绘制误差棒.。</td></tr><tr><td>"HIST" </td><td>绘制直方图。</td></tr><tr><td>"FUNC" </td><td>当直方图具有拟合函数时，此选项允许仅绘制拟合结果。</td></tr><tr><td>"SAME" </td><td>叠加在同一垫中的前一张图片上。 </td></tr><tr><td>"SAMES" </td><td>与“SAME”相同，绘制统计框。</td></tr><tr><td>"PFC" </td><td>调色板填充颜色：直方图的填充颜色取当前调色板。 </td></tr><tr><td>"PLC" </td><td>调色板线条颜色：直方图的线条颜色取当前调色板。</td></tr><tr><td>"PMC" </td><td>调色板标记颜色：直方图的标记颜色取当前调色板。</td></tr><tr><td>"LEGO" </td><td>绘制去除隐藏线的乐高图。</td></tr><tr><td>"LEGO1" </td><td>绘制隐藏表面移除的乐高图. </td></tr><tr><td>"LEGO2" </td><td>使用颜色绘制乐高图以显示单元格内容 当选项“0”与任何乐高选项一起使用时，不会绘制空箱。</td></tr><tr><td>"LEGO3" </td><td>绘制一个带有隐藏表面去除的乐高图，与乐高1类似，但不绘制每个乐高条的边界线。 </td></tr><tr><td>"LEGO4" </td><td>绘制一个带有隐藏表面去除的乐高图，就像乐高1一样，但每个乐高条上没有阴影效果。 </td></tr><tr><td>"TEXT" </td><td>将 bin 内容绘制为文本（通过 gStyle->SetPaintTextFormat 设置格式）。 </td></tr><tr><td>"TEXTnn" </td><td>将 bin 内容绘制为角度 nn (0 &#x3C; nn &#x3C;= 90) 的文本. </td></tr><tr><td>"X+" </td><td>TX 轴绘制在图的顶部。 </td></tr><tr><td>"Y+" </td><td>Y 轴绘制在图的右侧。</td></tr><tr><td>"MIN0" </td><td>将 Y 轴的最小值设置为 0，相当于 gStyle->SetHistMinimumZero()。 </td></tr></tbody></table>

**Options supported for 1D histograms**

<table><thead><tr><th width="125.5">Option </th><th>Description </th></tr></thead><tbody><tr><td>"AH" </td><td>绘制无轴直方图。 “A”可以与任何绘图选项组合。 例如，“AC”将直方图绘制为无轴的平滑曲线。</td></tr><tr><td>"][" </td><td>选择此选项时，不会绘制直方图的第一条和最后一条垂直线。</td></tr><tr><td>"B" </td><td>条形图选项。</td></tr><tr><td>"BAR" </td><td>与选项“B”类似，但可以用 3D 效果绘制条形。 </td></tr><tr><td>"HBAR" </td><td><mark style="color:green;">“HBAR” 与选项“BAR”类似，但条形是水平绘制的。</mark> </td></tr><tr><td>"C" </td><td>Draw a smooth Curve through the histogram bins. </td></tr><tr><td>"E0" </td><td>Draw error bars. Markers are drawn for bins with 0 contents. Combined with E1 or E2 it avoids error bars clipping </td></tr><tr><td>"E1" </td><td>Draw error bars with perpendicular lines at the edges. </td></tr><tr><td>"E2" </td><td>Draw error bars with rectangles. </td></tr><tr><td>"E3" </td><td>Draw a fill area through the end points of the vertical error bars. </td></tr><tr><td>"E4" </td><td>Draw a smoothed filled area through the end points of the error bars. </td></tr><tr><td>"E5" </td><td>Like E3 but ignore the bins with 0 contents. </td></tr><tr><td>"E6" </td><td>Like E4 but ignore the bins with 0 contents. </td></tr><tr><td>"X0" </td><td>When used with one of the "E" option, it suppress the error bar along X as <code>gStyle->SetErrorX(0)</code> would do. </td></tr><tr><td>"L" </td><td>Draw a line through the bin contents. </td></tr><tr><td>"P" </td><td>Draw current marker at each bin except empty bins. </td></tr><tr><td>"P*" </td><td>Draw a star marker at each bin except empty bins. </td></tr><tr><td>"P0" </td><td>Draw current marker at each bin including empty bins. </td></tr><tr><td>"PIE" </td><td>Draw histogram as a Pie Chart. </td></tr><tr><td>"*H" </td><td>Draw histogram with a * at each bin. </td></tr><tr><td>"LF2" </td><td>Draw histogram like with option "L" but with a fill area. Note that "L" draws also a fill area if the hist fill color is set but the fill area corresponds to the histogram contour. </td></tr></tbody></table>

**Options supported for 2D histograms**

<table data-header-hidden><thead><tr><th width="165.5"></th><th></th></tr></thead><tbody><tr><td>Option </td><td>Description </td></tr><tr><td>" " </td><td>Default (color plot). </td></tr><tr><td>"ARR" </td><td>Arrow mode. Shows gradient between adjacent cells. </td></tr><tr><td>"BOX" </td><td>A box is drawn for each cell with surface proportional to the content's absolute value. A negative content is marked with a X. </td></tr><tr><td>"BOX1" </td><td>A button is drawn for each cell with surface proportional to content's absolute value. A sunken button is drawn for negative values a raised one for positive. </td></tr><tr><td>"COL" </td><td>A box is drawn for each cell with a color scale varying with contents. All the none empty bins are painted. Empty bins are not painted unless some bins have a negative content because in that case the null bins might be not empty. <a href="https://root.cern.ch/doc/master/classTProfile2D.html"><code>TProfile2D</code></a> histograms are handled differently because, for this type of 2D histograms, it is possible to know if an empty bin has been filled or not. So even if all the bins' contents are positive some empty bins might be painted. And vice versa, if some bins have a negative content some empty bins might be not painted (default). </td></tr><tr><td>"COLZ" </td><td>Same as "COL". In addition the color palette is also drawn. </td></tr><tr><td>"COL2" </td><td>Alternative rendering algorithm to "COL". Can significantly improve rendering performance for large, non-sparse 2-D histograms. </td></tr><tr><td>"COLZ2" </td><td>Same as "COL2". In addition the color palette is also drawn. </td></tr><tr><td>"Z CJUST" </td><td>In combination with colored options "COL","CONT0" etc: Justify labels in the color palette at color boundaries. For more details see <a href="https://root.cern.ch/doc/master/classTPaletteAxis.html"><code>TPaletteAxis</code></a></td></tr><tr><td>"CANDLE" </td><td>Draw a candle plot along X axis. </td></tr><tr><td>"CANDLEX" </td><td>Same as "CANDLE". </td></tr><tr><td>"CANDLEY" </td><td>Draw a candle plot along Y axis. </td></tr><tr><td>"CANDLEXn" </td><td>Draw a candle plot along X axis. Different candle-styles with n from 1 to 6. </td></tr><tr><td>"CANDLEYn" </td><td>Draw a candle plot along Y axis. Different candle-styles with n from 1 to 6. </td></tr><tr><td>"VIOLIN" </td><td>Draw a violin plot along X axis. </td></tr><tr><td>"VIOLINX" </td><td>Same as "VIOLIN". </td></tr><tr><td>"VIOLINY" </td><td>Draw a violin plot along Y axis. </td></tr><tr><td>"VIOLINXn" </td><td>Draw a violin plot along X axis. Different violin-styles with n being 1 or 2. </td></tr><tr><td>"VIOLINYn" </td><td>Draw a violin plot along Y axis. Different violin-styles with n being 1 or 2. </td></tr><tr><td>"CONT" </td><td>Draw a contour plot (same as CONT0). </td></tr><tr><td>"CONT0" </td><td>Draw a contour plot using surface colors to distinguish contours. </td></tr><tr><td>"CONT1" </td><td>Draw a contour plot using line styles to distinguish contours. </td></tr><tr><td>"CONT2" </td><td>Draw a contour plot using the same line style for all contours. </td></tr><tr><td>"CONT3" </td><td>Draw a contour plot using fill area colors. </td></tr><tr><td>"CONT4" </td><td>Draw a contour plot using surface colors (SURF option at theta = 0). </td></tr><tr><td>"LIST" </td><td>Generate a list of <a href="https://root.cern.ch/doc/master/classTGraph.html">TGraph</a> objects for each contour. </td></tr><tr><td>"SAME0" </td><td>Same as "SAME" but do not use the z-axis range of the first plot. </td></tr><tr><td>"SAMES0" </td><td>Same as "SAMES" but do not use the z-axis range of the first plot. </td></tr><tr><td>"CYL" </td><td>Use Cylindrical coordinates. The X coordinate is mapped on the angle and the Y coordinate on the cylinder length. </td></tr><tr><td>"POL" </td><td>Use Polar coordinates. The X coordinate is mapped on the angle and the Y coordinate on the radius. </td></tr><tr><td>"SPH" </td><td>Use Spherical coordinates. The X coordinate is mapped on the latitude and the Y coordinate on the longitude. </td></tr><tr><td>"PSR" </td><td>Use PseudoRapidity/Phi coordinates. The X coordinate is mapped on Phi. </td></tr><tr><td>"SURF" </td><td>Draw a surface plot with hidden line removal. </td></tr><tr><td>"SURF1" </td><td>Draw a surface plot with hidden surface removal. </td></tr><tr><td>"SURF2" </td><td>Draw a surface plot using colors to show the cell contents. </td></tr><tr><td>"SURF3" </td><td>Same as SURF with in addition a contour view drawn on the top. </td></tr><tr><td>"SURF4" </td><td>Draw a surface using Gouraud shading. </td></tr><tr><td>"SURF5" </td><td>Same as SURF3 but only the colored contour is drawn. Used with option CYL, SPH or PSR it allows to draw colored contours on a sphere, a cylinder or a in pseudo rapidity space. In cartesian or polar coordinates, option SURF3 is used. </td></tr><tr><td>"AITOFF" </td><td>Draw a contour via an AITOFF projection. </td></tr><tr><td>"MERCATOR" </td><td>Draw a contour via an Mercator projection. </td></tr><tr><td>"SINUSOIDAL" </td><td>Draw a contour via an Sinusoidal projection. </td></tr><tr><td>"PARABOLIC" </td><td>Draw a contour via an Parabolic projection. </td></tr><tr><td>"MOLLWEIDE" </td><td>Draw a contour via an Mollweide projection. </td></tr><tr><td>"LEGO9" </td><td>Draw the 3D axis only. Mainly needed for internal use </td></tr><tr><td>"FB" </td><td>With LEGO or SURFACE, suppress the Front-Box. </td></tr><tr><td>"BB" </td><td>With LEGO or SURFACE, suppress the Back-Box. </td></tr><tr><td>"A" </td><td>With LEGO or SURFACE, suppress the axis. </td></tr><tr><td>"SCAT" </td><td>Draw a scatter-plot (deprecated option). </td></tr><tr><td>"[cutg]" </td><td>Draw only the sub-range selected by the <a href="https://root.cern.ch/doc/master/classTCutG.html">TCutG</a> named "cutg".</td></tr></tbody></table>
