# 2.2. 直方图 Histograms

Histogram是一种对数据分布情况的图形表示方式，适合用来表现数量上的差异。

一维histogram的标准形式是：

```cpp
TH1 *h1 = new TH1I("h1", "h1 title; x title; unit title", bins, x min, x max)
```

建立histogram之后，必须向其中填充数据：

```c
h1->Fill(x)         // 填入一个值x
h1->Fill(x, w)      // 以权重为w填入一个值x
```

从C++11开始新建一个对象可以用auto,其类型可自动匹配：

```c
auto *h1 = new TH1F
```

```
TH2* h2 = new TH2F("h2", "h2 title; x title; y title", x bins, x min, x max, y bins, y min, y max);
```









```
TH3* h3 = new TH3D("h3", "h3 title; x title; y title; z title");
// histogram 之间也可以完成简单的运算
TH1F h3 = h1*h2;
TH1F h3 = 8*h1;
```







## 画布的概念 Canvas

画布有很多的类供你个性化你的图标，比如调整坐标轴的形式、范围、标题名称、轴名称等等：

<details>

<summary>Canvas类的成员函数</summary>

```c
root [0] TCanvas *c1 = new TCanvas("c1","c1",600,600)
(TCanvas *) 0x14d73e360
root [1] c1->
AbsCoordinates
AbsPixeltoX
AbsPixeltoXY
AbsPixeltoY
AbstractMethod
AddExec
AppendPad
AreAllSignalsBlocked
AreSignalsBlocked
AutoExec
BlockAllSignals
BlockSignals
Browse
BuildLegend
ChangedBy
CheckedHash
Class
ClassName
Class_Name
Class_Version
Clear
ClearPadSave
Cleared
Clip
ClipPolygon
ClippingCode
Clone
Close
CloseToolTip
Closed
CollectClassSignalLists
Compare
Connect
Connected
Constructor
Copy
CopyPixmap
CopyPixmaps
CreateToolTip
DeclFileLine
DeclFileName
Delete
DeleteCanvasPainter
DeleteExec
DeleteToolTip
Destroyed
Destructor
Dictionary
Disconnect
DisconnectWidget
Disconnected
DistancetoLine
DistancetoPrimitive
Divide
DivideSquare
Draw
DrawClass
DrawClassObject
DrawClone
DrawClonePad
DrawCollideGrid
DrawColorTable
DrawCrosshair
DrawFrame
Dump
EditorBar
EmbedInto
Emit
EnterLeave
Error
EventPave
Execute
ExecuteEvent
ExecuteEventAxis
Fatal
FeedbackMode
FindObject
Flush
ForceUpdate
GetAbsHNDC
GetAbsWNDC
GetAbsXlowNDC
GetAbsYlowNDC
GetAfile
GetAspectRatio
GetAstat
GetAutoExec
GetBBox
GetBBoxCenter
GetBorderMode
GetBorderSize
GetBottomMargin
GetCanvas
GetCanvasID
GetCanvasImp
GetCanvasPainter
GetCanvasPar
GetClickSelected
GetClickSelectedPad
GetContextMenu
GetCrosshair
GetDISPLAY
GetDoubleBuffer
GetDrawOption
GetDtorOnly
GetEvent
GetEventX
GetEventY
GetFillColor
GetFillStyle
GetFrame
GetFrameBorderMode
GetFrameBorderSize
GetFrameFillColor
GetFrameFillStyle
GetFrameLineColor
GetFrameLineStyle
GetFrameLineWidth
GetGLDevice
GetGridx
GetGridy
GetHNDC
GetHighLightColor
GetIconName
GetLeftMargin
GetLineColor
GetLineStyle
GetLineWidth
GetListOfClassSignals
GetListOfConnections
GetListOfExecs
GetListOfPrimitives
GetListOfSignals
GetLogx
GetLogy
GetLogz
GetMaxPickDistance
GetMother
GetName
GetNumber
GetObjectInfo
GetObjectStat
GetOption
GetPad
GetPadPaint
GetPadPar
GetPadPointer
GetPadSave
GetPainter
GetPhi
GetPixmapID
GetPrimitive
GetRange
GetRangeAxis
GetRightMargin
GetSelected
GetSelectedOpt
GetSelectedPad
GetSelectedX
GetSelectedY
GetShowEditor
GetShowEventStatus
GetShowToolBar
GetShowToolTips
GetTheta
GetTickx
GetTicky
GetTitle
GetTopMargin
GetUniqueID
GetUxmax
GetUxmin
GetUymax
GetUymin
GetView
GetView3D
GetViewer3D
GetVirtCanvas
GetWNDC
GetWh
GetWindowHeight
GetWindowTopX
GetWindowTopY
GetWindowWidth
GetWw
GetX1
GetX2
GetXfile
GetXlowNDC
GetXsizeReal
GetXsizeUser
GetXstat
GetY1
GetY2
GetYfile
GetYlowNDC
GetYsizeReal
GetYsizeUser
GetYstat
HandleInput
HandleTimer
HasConnection
HasCrosshair
HasFixedAspectRatio
HasInconsistentHash
HasMenuBar
HasViewer3D
Hash
HighLight
HighPriority
HighlightConnect
Highlighted
Iconify
ImplFileLine
ImplFileName
IncrementPaletteColor
Info
InheritsFrom
Inspect
InvertBit
IsA
IsBatch
IsBeingResized
IsDestructed
IsDrawn
IsEditable
IsEqual
IsFolder
IsGrayscale
IsModified
IsOnHeap
IsRetained
IsSortable
IsTransparent
IsVertical
IsWeb
IsZombie
LowPriority
MakeDefCanvas
MayNotUse
Message
Modified
Modify
MoveOpaque
NextPaletteColor
Notify
NumberOfConnections
NumberOfSignals
Obsolete
OpaqueMoving
OpaqueResizing
Pad
PadInHighlightMode
PadInSelectionMode
PadtoX
PadtoY
Paint
PaintBorderPS
PaintBox
PaintFillArea
PaintFillAreaHatches
PaintFillAreaNDC
PaintHatches
PaintLine
PaintLine3D
PaintLineNDC
PaintModified
PaintPadFrame
PaintPolyLine
PaintPolyLine3D
PaintPolyLineNDC
PaintPolyMarker
PaintText
PaintTextNDC
Pick
Picked
PixeltoX
PixeltoXY
PixeltoY
PlaceBox
Pop
PopTopLevelSelectable
Print
ProcessedEvent
PushSelectableObject
PushTopLevelSelectable
RaiseWindow
Range
RangeAxis
RangeAxisChanged
RangeChanged
Read
RecordLatex
RecordPave
RecursiveRemove
RedrawAxis
ReleaseViewer3D
ResetAttFill
ResetAttLine
ResetAttPad
ResetBit
ResetDrawn
ResetToolTip
ResetView3D
Resize
ResizeOpaque
ResizePad
Resized
SaveAs
SaveFillAttributes
SaveLineAttributes
SavePrimitive
SaveSource
Selected
SetAfile
SetAstat
SetAttFillPS
SetAttLinePS
SetAttMarkerPS
SetAttTextPS
SetBBoxCenter
SetBBoxCenterX
SetBBoxCenterY
SetBBoxX1
SetBBoxX2
SetBBoxY1
SetBBoxY2
SetBatch
SetBit
SetBorderMode
SetBorderSize
SetBottomMargin
SetCanvas
SetCanvasImp
SetCanvasSize
SetClickSelected
SetClickSelectedPad
SetCopyGLDevice
SetCrosshair
SetCursor
SetDoubleBuffer
SetDrawOption
SetDtorOnly
SetEditable
SetFillAttributes
SetFillColor
SetFillColorAlpha
SetFillStyle
SetFixedAspectRatio
SetFolder
SetFrameBorderMode
SetFrameBorderSize
SetFrameFillColor
SetFrameFillStyle
SetFrameLineColor
SetFrameLineStyle
SetFrameLineWidth
SetGLDevice
SetGrayscale
SetGrid
SetGridx
SetGridy
SetHighLightColor
SetLeftMargin
SetLineAttributes
SetLineColor
SetLineColorAlpha
SetLineStyle
SetLineWidth
SetLogx
SetLogy
SetLogz
SetMargin
SetMaxPickDistance
SetName
SetNumber
SetObjectStat
SetPad
SetPadSave
SetPhi
SetRealAspectRatio
SetRetained
SetRightMargin
SetSelected
SetSelectedPad
SetSupportGL
SetTheta
SetTicks
SetTickx
SetTicky
SetTitle
SetToolTipText
SetTopMargin
SetUniqueID
SetVertical
SetView
SetViewer3D
SetWindowPosition
SetWindowSize
SetXfile
SetXstat
SetYfile
SetYstat
Show
ShowGuidelines
ShowMembers
Size
StartEditing
Streamer
StreamerNVirtual
SupportAlpha
SysError
TAttBBox2D
TAttFill
TAttLine
TAttPad
TCanvas
TObject
TPad
TQObject
TVirtualPad
TestBit
TestBits
ToggleAutoExec
ToggleEditor
ToggleEventStatus
ToggleToolBar
ToggleToolTips
UnZoomed
Update
UseCurrentStyle
UseGL
UtoAbsPixel
UtoPixel
VtoAbsPixel
VtoPixel
WaitPrimitive
Warning
Write
XYtoAbsPixel
XYtoPixel
XtoAbsPixel
XtoPad
XtoPixel
YtoAbsPixel
YtoPad
YtoPixel
cd
kAutoExec
kBitMask
kCanDelete
kCannotMove
kCannotPick
kClearAfterCR
kClipFrame
kFraming
kHasUUID
kHori
kInconsistent
kInvalidObject
kIsGrayscale
kIsOnHeap
kIsReferenced
kMenuBar
kMoveOpaque
kMustCleanup
kNoContextMenu
kNotDeleted
kObjInCanvas
kOverwrite
kPrintingPS
kResizeOpaque
kShowEditor
kShowEventStatus
kShowToolBar
kShowToolTips
kSingleKey
kWriteDelete
kZombie
ls
operator delete
operator delete[]
operator new
operator new[]
operator=
x3d
```

</details>



## 箱的概念 bin

在前一个例子中，你会看到`TH1I("h1", "h1 title",100,0.0,4.0)`中的参数，如`"h1"`表示将图片存为文件时，默认文件名为`h1`，`"h1 title"`指该histogram的标题为`h1 title`，`100,0.0,4.0`分别表示分bin数量`(nbins)`和轴范围`(xlow,xup)`，即将`0.0-4.0`的范围上分`100`个`bin`

那么什么是bin？<mark style="color:green;">bin的原意是垃圾箱或小箱子</mark>，在histogram中，我们将存放数据的bar，称为一个bin，bin的宽度取决于分bin数量及坐标轴的形式，如`SetLogx`：对x轴取对数坐标的形式，bin的大小随log变化，如果要求bin宽不随`logx`变化，可以参考[这里](https://www.bilibili.com/read/cv6640287/)

当不指定bin及坐标轴范围时（参数位置需要空出），ROOT会自动帮你匹配，<mark style="color:red;">自动的通常很丑</mark>

```cpp
   TH1* h1 = new TH1I("h1", "h1 title", , , );   // 一维整型直方图
```

<mark style="color:red;">同样，我们也可以精细控制分bin，此时请注意，数组的大小应为</mark><mark style="color:red;">`nbins+1`</mark><mark style="color:red;">，因为它包含下范围和上范围的轴值</mark> <mark style="color:red;"></mark>_<mark style="color:red;">**E.g.**</mark>_

```cpp
   double binEdges[] = { 0.0, 0.2, 0.5, 1., 2., 4. };
   TH1* h1 = new TH1D("h1", "h1 title", 6, binEdges );
   TH2* h2 = new TH2D("h2", "h2 title", 6, binEdges , 30, -1.5, 3.5);
```

<mark style="color:green;">**在命令行模式下，我们也可以通过下面的命令来完成简单的分bin：**</mark>

`root [0] TTree->Draw("TBranch>>(nbin,xlim,xup)")`

<mark style="color:green;">**(二维图使用>>(xbin,xmin,xmax,ybin,ymin,ymax)命令)**</mark>



## 随机函数 gRandom

```c
// 常用的内置随机函数
gRandom->Binomial(ntot,p)    // 二项分布
gRandom->Exp(tau)            // 指数分布
gRandom->Gaus(mean,sigma)    // 高斯分布
gRandom->Rndm()              // (0,1]均匀分布
gRandom->Poisson(mean)       // 泊松分布
gRandom->Landau(mean,sigma)  // 朗道分布
gRandom->Uniform(x1,x2)      // (x1,x2]均匀分布
```

<details>

<summary><strong>E.g. 创建Gaus数据</strong> </summary>

<pre class="language-cpp"><code class="lang-cpp"><strong>#include &#x3C;fstream>  // 当用到文件输入输出流时需要添加该头文件
</strong>
void create_data(){    // 在ROOT中，文件名与主函数名 
    float data=0.0;
    ofstream write; // out of file stream;stream name
    write.open("data.txt"); 

    for (int i=0; i&#x3C;30000;i++){
        data = gRandom -> Gaus (2,0.3);    // gaus分布的均值和宽度
        write &#x3C;&#x3C; data &#x3C;&#x3C;"\n";   // data write in stream
    }
    for (int k=0;k&#x3C;30000;k++){
        data = gRandom -> Gaus (-2,0.5);
        write &#x3C;&#x3C; data &#x3C;&#x3C;"\n";
    }
    write.close();
    cout &#x3C;&#x3C; "completed!"&#x3C;&#x3C;endl;
}
</code></pre>

</details>



## 填充数据 Fill

<mark style="color:red;">**填充步骤的重要性体现在，如果不将读取的数据填充进histogram，那么histogram无法正常绘制，填充是绘制histogram的必要步骤。**</mark>

填充的固定格式有：

```c
   // For 1-D histograms
   h1->Fill(x);
   h1->Fill(x,w); // with weight
   // For 2-D histograms and TProfile:
   h2->Fill(x,y);
   p2->Fill(x,y);
   h2->Fill(x,y,w);  // with weights
   p2->Fill(x,y,w);
   // For 3-D histograms and TProfile2D:
   h3->Fill(x,y,z);
   h3->Fill(x,y,z,w); // with weights
```

### 随机数填充

通常用于产生一个随机样本

<details>

<summary>E.g. 填充和绘制Gaus <strong>histogram</strong></summary>

<pre class="language-c"><code class="lang-c"><strong>#include &#x3C;fstream>  // file stream
</strong>
void ana(){
    TH1F *h1 = new TH1F("h1","Histogram Gaus",1000,-5,8);
    // Type Histogram 1D Float(example:TH1D = Type Histogram 1D Double)
    float data = 0.0;

    ifstream read; // input file stream
    read.open("data.txt");

    while(read.is_open()){
        read >> data;
        h1->Fill(data);
        if(read.eof()) break;   // .eof() = end of file()
    }
    h1->Draw();
}
</code></pre>

</details>

<figure><img src="../.gitbook/assets/unnamed.svg" alt=""><figcaption></figcaption></figure>

### 坐标填充

histogram也可以仅依靠坐标来绘制 _**E.g.**_

<details>

<summary>不同实验对GRB221009A的不同能量的光变曲线的测量结果</summary>

```c
#include <iostream>
#include <fstream>
#include <vector>
#include <TCanvas.h>
#include <TH1F.h>

void plot() {
	
	TCanvas *canvas = new TCanvas("canvas", "Histogram", 800, 800);
	canvas->Divide(1,4,0);
	
	TH1F *h1 = new TH1F("h1", "", 120, 0, 1200);
	std::ifstream file1("lightCurve221009AHxmt.txt");
	double x1, y1;
	while (file1 >> x1 >> y1) {h1->Fill(x1, y1);}
	h1->SetTitle(";;Rate [counts/bin]");
	h1->GetYaxis()->SetTitleSize(0.06);h1->GetYaxis()->CenterTitle();

	TH1F *h2 = new TH1F("h2","",120,0,1200);
	std::ifstream file2("lightCurve221009AFermi.txt");
	double x2, y2;
	while (file2 >> x2 >> y2) {h2->Fill(x2, y2);}
	h2->SetTitle(";;Rate [counts/bin]");
	h2->GetYaxis()->SetTitleSize(0.06);h2->GetYaxis()->CenterTitle();

	TH1F *h3 = new TH1F("h3","",120,0,1200);
	std::ifstream file3("lightCurve221009ALhaaso.txt");
	double x3, y3;
	while (file3 >> x3 >> y3) {h3->Fill(x3, y3);}
	h3->SetTitle(";;Rate [counts/bin]");
	h3->GetYaxis()->SetTitleSize(0.06);h3->GetYaxis()->CenterTitle();

    TH1F *h4 = new TH1F("h4","",120,0,1200);
    std::ifstream file4("lightCurve221009AHadar.txt");
    double x4, y4;
    while (file4 >> x4 >> y4) {h4->Fill(x4, y4*2);}
	h4->SetTitle(";T-T_0 [s];Rate [counts/bin]");
	h4->GetYaxis()->SetTitleSize(0.06);h4->GetYaxis()->CenterTitle();
	h4->GetXaxis()->SetTitleSize(0.06);h4->GetXaxis()->CenterTitle();

    canvas->cd(1);
	gStyle->SetOptStat(0);
	h1->SetFillColor(kYellow-6);
	h1->Draw("HIST");
	TLegend *l1 = new TLegend(0.6,0.6,0.893,0.89,"HXMT HE/Csl");
	l1->AddEntry(h1,"0.6-3MeV");
    l1->SetBorderSize(0);l1->Draw();

    canvas->cd(2);
	gStyle->SetOptStat(0);
    h2->SetFillColor(kGreen-6);
    h2->Draw("HIST");
    TLegend *l2 = new TLegend(0.6,0.6,0.893,0.89,"Fermi LAT");
    l2->AddEntry(h2,"0.1-500GeV");
    l2->SetBorderSize(0);l2->Draw();
    
    canvas->cd(3);
	gStyle->SetOptStat(0);
    h3->SetFillColor(kBlue-6);
    h3->Draw("HIST");
    TLegend *l3 = new TLegend(0.6,0.6,0.893,0.89,"LHAASO WCDA");
    l3->AddEntry(h3,"0.2-7TeV");
    l3->SetBorderSize(0);l3->Draw();
    
    canvas->cd(4);
	gStyle->SetOptStat(0);
    h4->SetFillColor(kMagenta-6);
    h4->Draw("HIST");
    TLegend *l4 = new TLegend(0.6,0.6,0.893,0.89,"HADAR");
    l4->AddEntry(h4,"0.01-10TeV");
    l4->SetBorderSize(0);l4->Draw();
    
	//canvas->Update();
}

```

</details>

## 二维直方 Histogram 2D

现在我们可以用上面的例子生成一幅二维直方图

<details>

<summary>E.g.1</summary>

```c
{
   TH2D h2("h2","Histogram filled with random numbers",40,-4,4,40,-20,20);
   float px, py;
   for (int i = 0; i < 25000; i++) {
      gRandom->Rannor(px,py);
      h2.Fill(px,5*py);
   }
   h2.DrawCopy("LEGO1");
}
```

</details>

<figure><img src="../.gitbook/assets/histogram2dgaus.svg" alt=""><figcaption></figcaption></figure>

<details>

<summary>E.g.2</summary>

<pre class="language-c"><code class="lang-c"><strong>void histogram2D(){
</strong>    TCanvas *c = new TCanvas("c","c",800,1200);
    c->Divide(2,3); 
    //新建画布800*1200，布局为2*3，横*高，主函数名需与文件名一致，即该文件名为"histogram3D.c"
    float x,y;
    TH1F *h1 = new TH1F("h1","1D histogram",50,-10,10);
    TH2F *h2 = new TH2F("h2","2D histogram",50,-10,10,50,-10,10);
    TH2F *h3 = new TH2F("h3","2D histogram",50,-10,10,50,-10,10);
    TH1D *ph;   //一维投影
 
    for (int i=0;i&#x3C;30000;i++){
        x=gRandom->Gaus(0,0.5);
        y=gRandom->Gaus(0,1);
        h1->Fill(3*x);
        h2->Fill(x,y);
        h3 -> Fill(x,y);
    }

    c->cd(1);
    h1->Draw();

    c->cd(2);
    h2->Draw("lego");

    c->cd(3);
    h3->Draw("lego2");

    c->cd(4);
    ph = h2->ProjectionX();
    ph->SetTitle("The projection of n2 on X");
    ph->Draw();
}
</code></pre>

</details>

<figure><img src="../.gitbook/assets/histogram3d.svg" alt=""><figcaption></figcaption></figure>

你同样可以在ROOT的命令行中，在现有画布内新建图像

```shell
root [1] c->cd(5)
(TVirtualPad *) 0x376dbd0
root [2] TF1 *f1 = new TF1("f1","sin(x)/x",-10,10)
(TF1 *) 0x3b2d290
root [3] f1->Draw()
root [4] 
```

<figure><img src="../.gitbook/assets/histogram3d2 (1).svg" alt=""><figcaption></figcaption></figure>

### 蜂巢图



